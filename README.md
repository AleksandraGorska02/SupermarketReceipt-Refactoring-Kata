# SupermarketReceipt-Refactoring-Kata

1. The first step was to familiarize myself with the code and identify code smells. 
2. Next, I created unit tests to ensure that the existing functionality was preserved during refactoring.
3. I then refactored the code by breaking down large method like 'handleOffers' into smaller, more manageable methods.This involved creating an interface and applying a strategy pattern. Classes implementing the interface were separated, each of them responsible for a different method of calculating the offer.In addition, the strategy selection has been changed to enum instead of ifs.
4. Then I noticed that classes implementing strategies use offer directly within themselves, which leads to the smell of Inappropriately Intimate. Therefore, the arguments in the interface have been changed, and now classes from strategoo only accept offerArgument.
5. The next step was to divide the files into appropriate folders to give the project structure.
6. Then I started wondering how to solve the problem of what discount should have been applied. In the repository, I found the ‘with_test’ branch where supermarket tests were carried out. Discounts were added there for specific products by the teller, which are stored in a map, which means that there is one type of discount per product.
7. After testing, I moved on to adding bundles. I added a new type of strategy, which unfortunately did not fit the interface because I needed access to different types of products, and so far it had only worked for one type. However, I decided to leave this ugly interface until I got it working so as not to get confused with the offers while writing. Bundles store the discount percentage to be applied and a map of products containing the product name and quantity required to meet the conditions.
 A function has also been added to calculate how many emax bundles we can create from the products in the basket (it will later be transferred to the strategy).
8. The next step was to interpret the coupons, aiming to make it as universal as possible. So each coupon contains data, valid from/to check validity, whether used (automatically set to false and when used we change the flag), quantityNeeded, quantityDiscounted, discountFactor, so in order to get the discount described in the example, all we need to do is set quantityNeeded to 6, quantityDiscounted to 6 and discountFactor to 0.5. I assumed that quantityDiscounted means the maximum number of discounted products “can buy 6 more at half price.” This is not precisely defined, so if you buy 11, you get a discount on 5, and if you buy 13, you still get a discount on 6.
This way, you can, for example, create coupons that simply discount a product by, say, 10% and set a maximum number of discounted products, e.g., 10. Then we set needed to 0.
9. 